{"ast":null,"code":"var _jsxFileName = \"/Users/Phil/Desktop/Web Dev/Projects/stock-screener/src/components/radarscreen/radarscreen.component.jsx\";\nimport React from 'react';\nimport ScreenHeader from '../screen-header/screen-header.component';\nimport GenerateGrid from '../generate-grid/generate-grid.component';\nimport AddColumnButton from '../add-column-button/add-column-button.component';\nimport { INTERVALS, SYMBOLS, API_TO_INDICATORS, INDICATORS_TO_API } from '../../assets/constants';\nimport './radarscreen.styles.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst permanentHeaders = ['Symbol', 'Interval'];\n\nclass RadarScreen extends React.Component {\n  constructor(_props) {\n    super(_props);\n\n    this.getHeaderTitle = () => {\n      const headerTitle = Object.keys(this.state).filter(key => this.state[key] !== null);\n      return headerTitle;\n    };\n\n    this.fetchAndSetState = (Symbol, apiIndicators, clearedState, valueRow, currentState) => {\n      // const { Symbol } = this.state;\n      let stateUpdates = {}; //fetch for all symbols and the apiIndicators\n\n      this.props.fetchRealTimeData(Symbol, apiIndicators).then(indicatorObject => {\n        // loop over all apiIndicators\n        apiIndicators.forEach(apiIndicator => {\n          // look up the name used for the column header (and state key)\n          const indicatorColumn = API_TO_INDICATORS[apiIndicator];\n          const updatedRow = valueRow ? Object.assign([], currentState[indicatorColumn], {\n            [valueRow]: indicatorObject[apiIndicator][0]\n          }) : indicatorObject[apiIndicator];\n          console.log(updatedRow, 'updatedRow', valueRow, Object.assign([], currentState[indicatorColumn], {\n            [valueRow]: indicatorObject[apiIndicator][0]\n          })); // merge the result of the current indicator column with the temp state object\n\n          stateUpdates = { ...stateUpdates,\n            // [indicatorColumn]: indicatorObject[apiIndicator]\n            [indicatorColumn]: updatedRow\n          };\n        });\n        return stateUpdates;\n      }) // update state to the updated indicators and the clearedState (all unused indicators set to null)\n      .then(stateUpdates => this.setState({ ...stateUpdates,\n        ...clearedState\n      } // , () => console.log(this.state,'s')\n      ));\n    };\n\n    this.onChange = (updatedValue, headerCol, valueRow) => {\n      const {\n        fetchRealTimeData\n      } = this.props;\n      const header = this.getHeaderTitle();\n      const apiIndicators = header.flatMap(item => permanentHeaders.includes(item) ? [] : [INDICATORS_TO_API[item]]);\n      let fetchedDataRow = {};\n      this.setState(prevState => {\n        const columnName = header[headerCol]; //which column changed (Symbol, Interval)\n\n        return {\n          [columnName]: Object.assign([], prevState[columnName], {\n            [valueRow]: updatedValue\n          })\n        };\n      }, () => {\n        const Symbol = new Array(this.state.Symbol[valueRow]);\n        this.fetchAndSetState(Symbol, apiIndicators, {}, valueRow, this.state); // fetchRealTimeData(new Array(this.state.Symbol[valueRow]), apiIndicators)\n        // .then(indicatorObject => {\n        // \tapiIndicators.forEach(apiIndicator => {\n        // \t\tconst indicatorColumn = API_TO_INDICATORS[apiIndicator];\n        // \t\tconst updatedRow = Object.assign([], this.state[indicatorColumn], {[valueRow]: indicatorObject[apiIndicator][0]})\n        // \t\tconsole.log(updatedRow,'updatedRow',valueRow)\n        // \t\tfetchedDataRow = {\n        // \t\t\t...fetchedDataRow,\n        // \t\t\t[indicatorColumn]: updatedRow\n        // \t\t}\n        // \t});\n        // \treturn fetchedDataRow;\n        // })\n        // .then(fetchedDataRow => this.setState(fetchedDataRow))\n      });\n    };\n\n    this.sortTable = event => {\n      this.setState((prevState, props) => {\n        const sortedTable = props.onSort(event, prevState);\n        return sortedTable;\n      });\n    };\n\n    this.getClassNameForHeader = name => {\n      const {\n        sortConfig\n      } = this.props;\n\n      if (!sortConfig) {\n        return;\n      }\n\n      const direction = sortConfig.direction === 1 ? 'ascending' : 'descending';\n      return sortConfig.sortedField === name ? direction : undefined;\n    };\n\n    this.handleColumnUpdate = names => {\n      const {\n        Symbol\n      } = this.state; // merge permanentHeaders with the updated column names\n\n      const headerTitles = [...permanentHeaders, ...names];\n      const apiIndicators = names.map(item => INDICATORS_TO_API[item]);\n      let clearedState = JSON.parse(JSON.stringify(this.state));\n      Object.keys(clearedState).forEach(key => {\n        if (!headerTitles.includes(key)) {\n          clearedState = { ...clearedState,\n            [key]: null\n          };\n        }\n      });\n      this.fetchAndSetState(Symbol, apiIndicators, clearedState);\n    };\n\n    this.state = {\n      Symbol: SYMBOLS.slice(0, 8),\n      Interval: Array(8).fill(INTERVALS[0]),\n      'Last Price': Array(8).fill(0)\n    };\n  }\n\n  componentDidMount() {\n    const {\n      Symbol\n    } = this.state;\n    const header = this.getHeaderTitle(); // map the header (= state keys) to INDICATORS_TO_API; do not include permanent headers\n\n    const apiIndicators = header.flatMap(item => permanentHeaders.includes(item) ? [] : [INDICATORS_TO_API[item]]);\n    this.fetchAndSetState(Symbol, apiIndicators);\n  }\n\n  render() {\n    const header = this.getHeaderTitle(); // passed from the withSort HOC\n\n    const {\n      sortConfig\n    } = this.props;\n    const usedIndicators = header.flatMap(item => permanentHeaders.includes(item) ? [] : [item]);\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"radarscreen\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"grid-container\",\n        style: {\n          gridTemplateColumns: `repeat(${header.length}, 1fr) 0`\n        },\n        children: [/*#__PURE__*/_jsxDEV(ScreenHeader, {\n          header: header,\n          sortTable: this.sortTable,\n          sortConfig: sortConfig\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 170,\n          columnNumber: 6\n        }, this), /*#__PURE__*/_jsxDEV(AddColumnButton, {\n          style: {\n            gridColumn: `${header.length}+1`\n          },\n          handleColumnUpdate: this.handleColumnUpdate,\n          usedIndicators: usedIndicators\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 6\n        }, this), /*#__PURE__*/_jsxDEV(GenerateGrid, { ...this.state,\n          header: header,\n          onChange: this.onChange\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 182,\n          columnNumber: 6\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 167,\n        columnNumber: 5\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 4\n    }, this);\n  }\n\n}\n\nexport default RadarScreen;","map":{"version":3,"sources":["/Users/Phil/Desktop/Web Dev/Projects/stock-screener/src/components/radarscreen/radarscreen.component.jsx"],"names":["React","ScreenHeader","GenerateGrid","AddColumnButton","INTERVALS","SYMBOLS","API_TO_INDICATORS","INDICATORS_TO_API","permanentHeaders","RadarScreen","Component","constructor","props","getHeaderTitle","headerTitle","Object","keys","state","filter","key","fetchAndSetState","Symbol","apiIndicators","clearedState","valueRow","currentState","stateUpdates","fetchRealTimeData","then","indicatorObject","forEach","apiIndicator","indicatorColumn","updatedRow","assign","console","log","setState","onChange","updatedValue","headerCol","header","flatMap","item","includes","fetchedDataRow","prevState","columnName","Array","sortTable","event","sortedTable","onSort","getClassNameForHeader","name","sortConfig","direction","sortedField","undefined","handleColumnUpdate","names","headerTitles","map","JSON","parse","stringify","slice","Interval","fill","componentDidMount","render","usedIndicators","gridTemplateColumns","length","gridColumn"],"mappings":"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","sourcesContent":["import React from 'react';\nimport ScreenHeader from '../screen-header/screen-header.component';\nimport GenerateGrid from '../generate-grid/generate-grid.component';\nimport AddColumnButton from '../add-column-button/add-column-button.component';\n\nimport { INTERVALS, SYMBOLS, API_TO_INDICATORS, INDICATORS_TO_API } from '../../assets/constants';\n\nimport './radarscreen.styles.css';\n\nconst permanentHeaders = ['Symbol', 'Interval'];\n\n\n\n\nclass RadarScreen extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tSymbol: SYMBOLS.slice(0,8),\n\t\t\tInterval: Array(8).fill(INTERVALS[0]),\n\t\t\t'Last Price': Array(8).fill(0)\n\t\t}\n\t}\n\n\tgetHeaderTitle = () => {\n\t\tconst headerTitle = Object.keys(this.state).filter(key => this.state[key] !== null);\n\t\treturn headerTitle;\n\t}\n\n\t\n\tfetchAndSetState = (Symbol, apiIndicators, clearedState, valueRow, currentState) => {\n\t\t\n\t\t// const { Symbol } = this.state;\n\n\t\tlet stateUpdates = {};\n\n\t\t//fetch for all symbols and the apiIndicators\n\t\tthis.props.fetchRealTimeData(Symbol, apiIndicators)\n\t\t.then(indicatorObject => {\n\t\t\t// loop over all apiIndicators\n\t\t\tapiIndicators.forEach(apiIndicator => {\n\t\t\t\t// look up the name used for the column header (and state key)\n\t\t\t\tconst indicatorColumn = API_TO_INDICATORS[apiIndicator];\n\n\t\t\t\tconst updatedRow = valueRow ? Object.assign([], currentState[indicatorColumn], {[valueRow]: indicatorObject[apiIndicator][0]}) : indicatorObject[apiIndicator]\n\t\t\t\tconsole.log(updatedRow,'updatedRow',valueRow, Object.assign([], currentState[indicatorColumn], {[valueRow]: indicatorObject[apiIndicator][0]}))\n\n\t\t\t\t// merge the result of the current indicator column with the temp state object\n\t\t\t\tstateUpdates = {\n\t\t\t\t\t...stateUpdates,\n\t\t\t\t\t// [indicatorColumn]: indicatorObject[apiIndicator]\n\t\t\t\t\t[indicatorColumn]: updatedRow\n\t\t\t\t};\n\t\t\t});\n\t\t\treturn stateUpdates\n\t\t})\n\t\t// update state to the updated indicators and the clearedState (all unused indicators set to null)\n\t\t.then(stateUpdates => this.setState({...stateUpdates,...clearedState}\n\t\t\t// , () => console.log(this.state,'s')\n\t\t))\n\t}\n\n\tcomponentDidMount() {\n\t\tconst { Symbol } = this.state;\n\n\t\tconst header = this.getHeaderTitle();\n\n\t\t// map the header (= state keys) to INDICATORS_TO_API; do not include permanent headers\n\t\tconst apiIndicators = header.flatMap(item => \n\t\t\tpermanentHeaders.includes(item) ? [] : [INDICATORS_TO_API[item]]\n\t\t)\n\t\t\n\t\tthis.fetchAndSetState(Symbol, apiIndicators);\n\t}\n\n\tonChange = (updatedValue, headerCol, valueRow) => {\n\n\t\tconst { fetchRealTimeData } = this.props;\n\t\tconst header = this.getHeaderTitle();\n\n\t\tconst apiIndicators = header.flatMap(item => \n\t\t\tpermanentHeaders.includes(item) ? [] : [INDICATORS_TO_API[item]]\n\t\t)\n\n\t\tlet fetchedDataRow = {};\n\n\t\tthis.setState(prevState => {\n\t\t\tconst columnName = header[headerCol]; //which column changed (Symbol, Interval)\n\t\t\treturn {\n\t\t\t\t[columnName]: Object.assign([], prevState[columnName], {[valueRow]: updatedValue})\n\t\t\t}\n\t\t}\n\t\t,\n\t\t() => {\n\t\t\tconst Symbol = new Array(this.state.Symbol[valueRow]);\n\t\t\tthis.fetchAndSetState(Symbol, apiIndicators, {}, valueRow, this.state);\n\n\t\t\t// fetchRealTimeData(new Array(this.state.Symbol[valueRow]), apiIndicators)\n\t\t\t// .then(indicatorObject => {\n\t\t\t// \tapiIndicators.forEach(apiIndicator => {\n\t\t\t// \t\tconst indicatorColumn = API_TO_INDICATORS[apiIndicator];\n\t\t\t// \t\tconst updatedRow = Object.assign([], this.state[indicatorColumn], {[valueRow]: indicatorObject[apiIndicator][0]})\n\t\t\t// \t\tconsole.log(updatedRow,'updatedRow',valueRow)\n\n\t\t\t// \t\tfetchedDataRow = {\n\t\t\t// \t\t\t...fetchedDataRow,\n\t\t\t// \t\t\t[indicatorColumn]: updatedRow\n\t\t\t// \t\t}\n\t\t\t// \t});\n\t\t\t\t\n\t\t\t// \treturn fetchedDataRow;\n\t\t\t// })\n\t\t\t// .then(fetchedDataRow => this.setState(fetchedDataRow))\n\n\n\t\t})\n\t}\n\n\tsortTable = (event) => {\n\t\tthis.setState((prevState, props) => {\n\t\t\tconst sortedTable = props.onSort(event, prevState);\n\t\t\treturn sortedTable;\n\t\t});\n\t}\n\n\tgetClassNameForHeader = name => {\n\t\tconst { sortConfig } = this.props;\n\t\tif (!sortConfig) {\n\t\t\treturn;\n\t\t}\n\t\tconst direction = sortConfig.direction === 1 ? 'ascending' : 'descending'; \n\t\treturn sortConfig.sortedField === name ? direction : undefined;\n\t};\n\n\thandleColumnUpdate = names => {\n\t\tconst { Symbol } = this.state;\n\t\t// merge permanentHeaders with the updated column names\n\t\tconst headerTitles = [...permanentHeaders, ...names];\n\n\t\tconst apiIndicators = names.map(item => INDICATORS_TO_API[item]);\n\n\t\tlet clearedState = JSON.parse(JSON.stringify(this.state));\n\n\t\tObject.keys(clearedState).forEach(key => {\n\t\t\tif(!headerTitles.includes(key)) {\n\t\t\t\tclearedState = {\n\t\t\t\t\t...clearedState,\n\t\t\t\t\t[key]: null\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tthis.fetchAndSetState(Symbol,apiIndicators,clearedState);\n\t}\n\t\n\trender() {\n\t\tconst header = this.getHeaderTitle();\n\t\t// passed from the withSort HOC\n\t\tconst { sortConfig } = this.props;\n\n\t\tconst usedIndicators = header.flatMap(item => \n\t\t\tpermanentHeaders.includes(item) ? [] : [item]\n\t\t);\n\n\t\treturn (\n\t\t\t<div className=\"radarscreen\">\n\t\t\t\t<div id=\"grid-container\" \n\t\t\t\t\tstyle={{gridTemplateColumns: `repeat(${header.length}, 1fr) 0`}}\n\t\t\t\t>\n\t\t\t\t\t<ScreenHeader \n\t\t\t\t\t\theader={header}\n\t\t\t\t\t\tsortTable={this.sortTable}\n\t\t\t\t\t\tsortConfig={sortConfig}\n\t\t\t\t\t/>\n\t\t\t\t\t<AddColumnButton \n\t\t\t\t\t\tstyle={{\n                            gridColumn: `${header.length}+1`\n                        }}\n\t\t\t\t\t\thandleColumnUpdate={this.handleColumnUpdate}\n\t\t\t\t\t\tusedIndicators={usedIndicators}\n\t\t\t\t\t/>\n\t\t\t\t\t<GenerateGrid \n\t\t\t\t\t\t{...this.state}\n\t\t\t\t\t\theader={header}\n\t\t\t\t\t\tonChange={this.onChange}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t</div>\n\t\t)\n\t}\n}\n\nexport default RadarScreen;"]},"metadata":{},"sourceType":"module"}